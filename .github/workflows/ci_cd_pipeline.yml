name: CI/CD

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  # ---------------------------------------------------
  # 1Ô∏è‚É£ UNIT TESTS
  # ---------------------------------------------------
  unit-tests:
    name: üß™ Unit Tests
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: pip install -r requirements.txt

      - name: Run unit tests
        run: python -m pytest tests/unit -v

  # ---------------------------------------------------
  # 2Ô∏è‚É£ INTEGRATION TESTS (Docker Compose)
  # ---------------------------------------------------
  integration-tests:
    name: üîó Integration Tests (Docker Compose)
    runs-on: ubuntu-latest
    needs: unit-tests
    environment: staging # Use secrets from staging environment

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify Docker Compose
        run: docker compose version

      - name: Create temporary .env.test file
        run: |
          echo "ENV=TEST" > .env.test
          echo "DB_HOST=${{ secrets.DB_HOST }}" >> .env.test
          echo "DB_PORT=${{ secrets.DB_PORT }}" >> .env.test
          echo "MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}" >> .env.test
          echo "MYSQL_USER=${{ secrets.MYSQL_USER }}" >> .env.test
          echo "MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}" >> .env.test
          echo "MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}" >> .env.test
          echo "DATABASE_URL=mysql+mysqlconnector://${{ secrets.MYSQL_USER }}:${{ secrets.MYSQL_PASSWORD }}@${{ secrets.DB_HOST }}:${{ secrets.DB_PORT }}/${{ secrets.MYSQL_DATABASE }}" >> .env.test
          cat .env.test

      - name: Build and start containers
        run: docker compose -f docker-compose.test.yml --env-file .env.test up -d --build

      - name: Run integration tests
        run: docker exec crypto_notifier_app_test python -m pytest tests/integration -v

      - name: Tear down environment
        if: always()
        run: docker compose -f docker-compose.test.yml --env-file .env.test down -v

  # ---------------------------------------------------
  # 3Ô∏è‚É£ BUILD & PUSH DOCKER IMAGE
  # ---------------------------------------------------
  build:
    name: üê≥ Build Docker Image
    needs: [unit-tests, integration-tests]
    runs-on: ubuntu-latest
    outputs:
      image-name: ${{ steps.meta.outputs.image-name }}

    steps:
      - uses: actions/checkout@v4

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Define image name
        id: meta
        run: |
          IMAGE_NAME="ghcr.io/${{ github.repository }}:latest"
          echo "image-name=$IMAGE_NAME" >> $GITHUB_OUTPUT

      - name: Build and push Docker image
        run: |
          docker buildx create --use
          docker buildx build \
            --platform linux/amd64,linux/arm64 \
            -t ${{ steps.meta.outputs.image-name }} \
            --push .

  # ---------------------------------------------------
  # 4Ô∏è‚É£ DEPLOY TO RASPBERRY PI
  # ---------------------------------------------------
  deploy:
    name: üöÄ Deploy to Raspberry Pi
    needs: build
    runs-on: ubuntu-latest
    environment: prod # Uses your "prod" environment secrets

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Enable IPv6 (for Raspberry Pi)
        uses: fscarmen/warp-on-actions@v1.1
        with:
          stack: dual

      # Copy docker-compose file to Pi
      - name: Deploy via SSH (copy only Compose file)
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SSH_TARGET }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          protocol: tcp6
          port: ${{ secrets.SSH_PORT }}
          source: "docker-compose.prod.yml"
          target: "~/crypto_notifier/"

      # Run deploy commands via SSH
      - name: Run deployment commands via SSH
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_TARGET }}
          username: ${{ secrets.SSH_USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          protocol: tcp6
          port: ${{ secrets.SSH_PORT }}
          command_timeout: 600s
          script: |
            echo "üöÄ Deploying latest GHCR image..."

            # Ensure target folder exists
            mkdir -p ~/crypto_notifier
            cd ~/crypto_notifier || exit 1

            # Generate .env.prod from GitHub secrets
            echo "üß© Writing .env.prod from secrets..."
            cat <<EOF > .env.prod
            ENV=PROD
            DB_HOST=${{ secrets.DB_HOST }}
            DB_PORT=${{ secrets.DB_PORT }}
            MYSQL_DATABASE=${{ secrets.MYSQL_DATABASE }}
            MYSQL_USER=${{ secrets.MYSQL_USER }}
            MYSQL_PASSWORD=${{ secrets.MYSQL_PASSWORD }}
            MYSQL_ROOT_PASSWORD=${{ secrets.MYSQL_ROOT_PASSWORD }}
            DATABASE_URL=mysql+mysqlconnector://${{ secrets.MYSQL_USER }}:${{ secrets.MYSQL_PASSWORD }}@${{ secrets.DB_HOST }}:${{ secrets.DB_PORT }}/${{ secrets.MYSQL_DATABASE }}
            EOF

            # Pull latest image from GHCR
            echo "üêã Pulling latest image from GHCR..."
            docker compose -f docker-compose.prod.yml --env-file .env.prod pull

            # Restart containers with new image
            echo "üêã Restarting containers..."
            docker compose -f docker-compose.prod.yml --env-file .env.prod down || true
            docker compose -f docker-compose.prod.yml --env-file .env.prod up -d

            echo "‚úÖ Deployment complete!"
